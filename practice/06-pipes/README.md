# Комуникация между процеси (pipes)

Именованите и неименованите тръби имат различни приложения и характеристики. Неименованите тръби се използват за обмен на данни между свързани процеси, като родителски и дъщерен процес. Те се създават чрез системното повикване pipe(), който връща два файлови дескриптора – един за четене и един за писане. Данните се предават чрез буфер, управляван от ядрото, който се намира в паметта и не е видим във файловата система. Тези тръби са временни, което означава, че съществуват само докато са отворени, а съдържанието им се губи, след като бъдат затворени. Четенето блокира, ако няма налични данни за четене, а писането блокира, ако буферът е пълен.

Именованите тръби, от друга страна, позволяват комуникация между несвързани процеси. Те се създават с командата mkfifo() и съществуват като специални файлове във файловата система. Тези тръби могат да бъдат отворени както за четене, така и за писане от различни процеси. Въпреки че изглеждат като файлове, именованите тръби също съхраняват данните в паметта на ядрото и не записват информация на диска. Четенето и писането в именованите тръби следват същите блокиращи правила – четенето блокира, ако няма налични данни, а писането блокира, когато буферът достигне максималния си размер, зададен от ядрото.


## Описание на файловете

### **00-introduction.c**
Този файл демонстрира основната употреба на канали (**pipes**) за комуникация между процеси.

- **Описание:**
  - Родителският процес пише съобщение в канала.
  - Дъщерният процес чете съобщението от канала и го принтира.
  - Има пример за използване на блокиращ и неблокиращ режим (чрез `fcntl`).

- **Основни функции:**
  - `pipe()`: Създава канал (pipe) за комуникация.
  - `fork()`: Създава нов процес.
  - `write()`: Записва данни в канала.
  - `read()`: Чете данни от канала.

---

### **01-ls-pipe-grep.c**
Този файл демонстрира използването на канал за свързване на два процеса, изпълняващи различни програми (`ls` и `grep`), чрез пренасочване на стандартния вход и изход.

- **Описание:**
  - Дъщерният процес изпълнява `ls -la`, като изходът му се пренасочва към канала.
  - Родителският процес изпълнява `grep .c`, като входът му се пренасочва към канала.

- **Основни функции:**
  - `dup()`: Дублира файлов дескриптор, за да пренасочи стандартния вход или изход.
  - `execlp()`: Стартира програма (`ls` или `grep`), замествайки текущия процес.

---

### **02-ls-pipe-grep-pipe-cowsay.c**
Този файл демонстрира свързване на три процеса чрез два канала. Това е пример за верижна обработка на данни между процеси.

- **Описание:**
  - Първият процес изпълнява `ls -la` и записва изхода в първия канал.
  - Вторият процес чете от първия канал, изпълнява `grep .c`, и записва резултата във втория канал.
  - Третият процес чете от втория канал и изпълнява `cowsay`, за да покаже резултата в забавен формат.

- **Основни функции:**
  - `pipe()`: Създава два канала за свързване на трите процеса.
  - `dup()`: Пренасочва файловите дескриптори за вход и изход.
  - `execlp()`: Стартира програми (`ls`, `grep`, `cowsay`).

### **03-sender.c** and **03-receiver.c**
#### **Receiver Program**
Тази програма представлява получател в чат приложение, използващо именувани канали , за комуникация между два процеса.

- **Описание:**
  - Създава именуван канал (`mkfifo`) с име `chat_pipe`.
  - Отваря канала за четене (`O_RDONLY`).
  - Чака съобщения от подателя и ги изписва на екрана.
  - Ако получи съобщение "exit" или подателят прекрати връзката, програмата се затваря.

- **Основни функции:**
  - `mkfifo()`: Създава именуван канал  с посоченото име.
  - `open()`: Отваря канала за четене.
  - `read()`: Чете съобщения от канала.
  - `unlink()`: Изтрива канала от файловата система след затваряне.

#### **Sender Program**
Тази програма представлява подател в чат приложение, използващо именувани канали , за комуникация между два процеса.

- **Описание:**
  - Създава именуван канал (`mkfifo`) с име `chat_pipe`.
  - Отваря канала за писане (`O_WRONLY`).
  - Чете въведен текст от стандартния вход, записва го в буфера и го изпраща през канала.
  - Ако подателят въведе "exit", програмата се затваря.

- **Основни функции:**
  - `mkfifo()`: Създава именуван канал  с посоченото име.
  - `open()`: Отваря канала за писане.
  - `read()`: Чете символи от стандартния вход един по един.
  - `write()`: Изпраща съобщения през канала.
  - `unlink()`: Изтрива канала от файловата система след затваряне.

---

## Полезни функции за работа с канали

### **pipe()**
- Създава комуникационен канал между два процеса.
- Аргументи:
  - Масив от два файлови дескриптора: `pipefd[0]` за край за четене и `pipefd[1]` край за писане.
- Пример:
  ```c
  int pipefd[2];
  if (pipe(pipefd) == -1) {
      perror("pipe");
  }

### **dup() и dup2()**
- **Описание**:
  - `dup()` и `dup2()` се използват за дублиране на файлови дескриптори.
  - Когато дублирате файлов дескриптор, новият файлов дескриптор става препратка към същия обект (файл, канал и т.н.) в системната таблица на файлове.
  - Това е полезно за пренасочване на стандартния поток за вход (`STDIN_FILENO`), изход (`STDOUT_FILENO`) или грешки (`STDERR_FILENO`) към друг файлов дескриптор.

- **Как работи**:
  - `dup()`: Дублира даден файлов дескриптор, като използва най-ниския наличен номер в таблицата на файлови дескриптори.
  - `dup2()`: Позволява дублиране на файлов дескриптор в конкретен файлов дескриптор, който се задава като аргумент.

### **mkfifo()**
- **Описание**:
  - `mkfifo()` създава именуван канал  с определени права за достъп.
  - Използва се за създаване на комуникационна връзка между два или повече процеса.
- **Аргументи**:
  - `const char *pathname`: Името на канала.
  - `mode_t mode`: Права за достъп (например `0666` за четене и писане от всички).
- **Пример**:
  ```c
  if (mkfifo("chat_pipe", 0666) == -1) {
      perror("mkfifo");
  }
  ```


---

### **Пример с обяснение за dup**
Следният код показва как изходът `stdout` се пренасочва към **pipefd[1]** (края за писане на каналa):

```c
close(STDOUT_FILENO);      // Затваря стандартния изход (fd = 1) и го освобождава.
dup(pipefd[1]);            // Дублира pipefd[1], като го пренасочва към fd = 1 (STDOUT_FILENO), защото 1 е най-ниският свободен дескриптор (тъй като го освободихме на предишният ред).
close(pipefd[1]);          // Затваря оригиналния pipefd[1], тъй като вече не е нужен.
```