# Домашна работа №1

Домашна работа №1 включва работа с файлови дескриптори и процеси. Състои се от 4 задачи, като всяка една от тях ви носи една единица от оценката (т.е. 1 задача за Среден 3, 2 задачи за Добър 4, т.н.)

В заданието в Google Classroom трябва да предадете архив с име `hw01-11b-NN-Name-Surname`, като замените `NN` с номера си в клас и `Name` и `Surname` с двете си имена.

Шаблон на този архив можете да изтеглите от [тук](https://github.com/angel-penchev/os-tues-2023-2024/blob/main/homework/01/hw01-11b-NN-Name-Surname.zip).

Срокът на домашната работа е **до 03.12.2023 (неделя), 23:59:59**. В часът, който имаме **на 07.12.2023 (четвъртък)** ще ви извиквам индивидуално да ми представите домашните си работи. Съответно, за да улесните себе си и мен, **пишете четлив и качествен код**.

## Задача 1 - `lseek`

- Целта на задачата е да се реализира parser за абстрактна блокова система, който да извежда информацията на стандартния изход (stdout). Системата се състои от множество структури (блокове) съдържащи в себе си информация и адрес (отместване от началото на файла) на следващия блок. Приемете, че един `block` е дефиниран по следния начин:

  ```c
  typedef struct
  {
      char data;
      unsigned char nextElementAddress;
  } block;
  ```

- Размерът на цялата система е 128 блока, а краят ѝ се разпознава по това, че в полето за адрес е записанo числото `0`. В началото на файла е записан първия блок.

- Пример за изпълнението на програмата:
  ```bash
  $ ./lseek example.hidden
  <some hidden message :D>
  ```

- Програмата ви трябва да обработва грешки при отваряне и четене на файла.
  ```bash
  $ ./lseek nonexistent.txt
  ./sh: nonexistent.txt: No such file or directory
  ```

- За реализацията на програмата трябва да използвате `lseek` системната функция, заедно с `open`, `close`, `read` и `write`.


## Задача 2 - `tail`

- Целта на задачате е да се реализира стандартната UNIX команда `tail`.

- Командата `tail` се използва за показване на последните редове на файлове. От командния ред програмата получава списък от файлове и започва да ги обработва като последните 10 реда от всеки файл последователно се копират в стандартния изход (stdout), разделени със заглавна секция.

- Ако файлът съдържа по-малко от 10 реда, цялото негово съдържание се копира в стандартния изход.

- Например, ако са дадени два файла със следното съдържание `a.txt`:

  ```
  one
  two
  three
  four
  five
  six
  seven
  eight
  nine
  ten
  eleven
  ```

  и `b.txt`:
  ```
  1234 1234
  567
  890
  ```

  тогава:
  ```
  $ ./tail a.txt b.txt
  ==> a.txt <==
  two
  three
  four
  five
  six
  seven
  eight
  nine
  ten
  eleven

  ==> b.txt <==
  1234 1234
  567
  890
  ```

- При наличието на само един аргумент, заглавната секция се пропуска.

- Ако някой от аргументите на `tail` не е файл или файлът не може да се отвори, то програмата трябва да изведе съобщение на стандартния изход за грешка (stderr).

  Например, ако бъдат предадени аргументи, които не са файлове:
  ```bash
  ./tail aa bb
  ```
  съобщението трябва да бъде оформено по следния начин:
  ```bash
  ./tail: cannot open 'aa' for reading: No such file or directory
  ./tail: cannot open 'bb' for reading: No such file or directory
  ```

- Ако някой от аргументите на `tail` е файл, който не може да се прочете, то програмата трябва да изведе съобщение за грешка. Например, ако бъдат предадени аргументи, които са директории:
  ```bash
  ./tail /tmp/
  ```
  съобщението трябва да бъде оформено по следния начин:
  ```bash
  ./tail: error reading '/tmp/': Is a directory
  ```

- Ако `./tail` не може да запише прочетеното на стандартния изход, то програмата трябва да изведе съобщение на стандартния изход за грешка (stderr). Например, ако дискът е пълен:
  ```bash
  ./tail a.txt > /dev/full
  ```
  съобщението трябва да бъде оформено по следния начин:
  ```
  ./tail: error writing 'standard output': No space left on device
  ```

- Ако `./tail` не може да затвори успешно някой файл, то програмата трябва да изведе съобщение на стандартния изход за грешка (stderr). Например:
  ```
  ./tail b.txt
  ```
  съобщението трябва да бъде оформено по следния начин:
  ```
  ./tail: error reading 'b.txt': Input/output error
  ```

- При грешка в един файл, то изпълнението трябва да продължи към следващите (програмата не трябва да приключи).

- За реализацията на програмата трябва да използвате `lseek`, `open`, `close`, `read` и `write` системните функции.


## Задача 3 - `watch`

- Целта на задачата е да се реализира системната команда `watch`.

- На командния ред на `watch` се подава друга команда, която трябва да се изпълнява периодично - на всеки 2 секунди.

  Например, ако програмата ви се извика по следния начин:

  ```bash
  ./watch date
  ```

  то на всеки 2 секунди трябва да се извиква командата `date`. Отброяването на 2-те секунди започва след приключването на предходното извикване на подадената команда.

  ```bash
  Tue Nov 14 05:25:34 EET 2023
  Tue Nov 14 05:25:36 EET 2023
  Tue Nov 14 05:25:38 EET 2023
  Tue Nov 14 05:25:40 EET 2023
  Tue Nov 14 05:25:42 EET 2023
  ...
  ```

  Програмата ви не трябва да приключва, а трябва да извиква подадената команда постоянно.

- На командия ред може да бъде подаден повече от един аргумент - допълнителни аргументи на подадената команда. Вашата програма трябва да предаде допълнителните аргументи на извикваната програма, така както са подадени на вашата.

  Например, ако програмата ви се извика по следния начин:

  ```bash
  ./watch date -u
  ```

  то на всеки 2 секунди трябва да се извиква командата `date` с аргумент `-u` (`-u`/`--utc` определя дата).
  
  ```bash
  Tue Nov 14 03:25:34 UTC 2023
  Tue Nov 14 03:25:36 UTC 2023
  Tue Nov 14 03:25:38 UTC 2023
  Tue Nov 14 03:25:40 UTC 2023
  Tue Nov 14 03:25:42 UTC 2023
  ...
  ```

- Програмата трябва да показва информация за грешки. Ако подадения аргумент не е изпълнима команда, то програмата трябва да изведе съобщение за грешка.  Например, ако на командния ред на програмата се подаде `./aa` и в текущата директория няма файл с такова име, то програмата трябва да формира следното съобщение:

  ```bash
  ./watch ./aa
  ./aa: No such file or directory
  ./aa: No such file or directory
  ./aa: No such file or directory
  ./aa: No such file or directory
  ./aa: No such file or directory
  ...
  ```

  Ако `fork` не успее да създаде нов процес, то трябва да се изведе съобщение за грешка:
  ```bash
  ./watch ls
  fork: Cannot allocate memory
  fork: Cannot allocate memory
  fork: Cannot allocate memory
  fork: Cannot allocate memory
  fork: Cannot allocate memory
  ...
  ```
  
  В случай на грешка при изпълнение на дадена команда, то вашата програма не трябва да приключва.

- След завършване на работата на създадения по този начин процес, родителския процес задължително трябва да провери статуса на завършване на детето.

- За реализцията на програмата трябва да използвате системните функции `fork`, `waitpid` и функция от семейството функции `exec`.

## Задача 4 - `sh`
Целта на задачата е да се реализира прост команден интерпретатор - `sh`.

- При стартиране на програмата, тя започва да чете редове от стандартния вход и да ги интерпретира. За тази цел програмата трябва да раздели командния ред на думи, като за разделител се използва интервал (`" "`).

  Например, ако на стандартния вход се напише следния ред:

  ```bash
  /bin/ls -l /usr/include
  ```

  то командния интерпретатор трябва го превърне в следния масив от думи:

  ```js
  {"/bin/ls", "-l", "/usr/include"}
  ```

  Първата дума се интерпретира като име на файл, който трябва да се изпълни. Програмата трябва да се опита да изпълни този файл, а като аргументи от командния ред трябва се предаде масив от всички думи в командния ред.

  В разгледания пример при команден ред:
  ```bash
  /bin/ls -l /usr/include
  ```
  програмата трябва да се опита да изпълни файла и да му предаде следния масив от аргументи:
  ```js
  {"/bin/ls", "-l", "/usr/include"}
  ```

- Ако първата дума от командният ред не е име на файл, то програмата трябва да изведе съобщение `No such file or directory`. Например, ако на стандартния вход на програмата се въведе `./aa` и в текущата директория няма файл с такова име, то програмата трябва да формира следното съобщение:
  ```bash
  $ ./aa
  ./aa: No such file or directory
  ```

  Ако `fork` не успее да създаде нов процес, то трябва да се изведе съобщение за грешка:
  ```bash
  $ /bin/echo
  fork: Cannot allocate memory
  ```

  В случай на грешка при изпълнение на дадена команда, то вашата програма не трябва да приключва. Програмата ви трябва да продължи да приема команди докато има символи в стандартния вход.

- Началото на всеки ред, който очаква потребителски вход, трябва да започва с: "$ "

- За реализцията на програмата трябва да използвате системните функции `fork`, `waitpid` и функция от семейството функции `exec`.

---
**ВАЖНО:** Напомням ви, че домашното ще бъде проверявано за плагиатство! Ако ви е нужна помощ, не се притеснявайте да се свържете с мен в Discord - `@justtsb` или по имейл на `angel.penchev.tsb@gmail.com`.

Пожелавам ви успех! ✨🥹